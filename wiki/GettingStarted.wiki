#summary A quick guide to getting started with the JSR 311 plugin for Grails.
#labels Featured

<wiki:toc/>

=Overview=

This page helps you getting started with the JSR 311 plugin for Grails. It is assumed that you have a basic understanding of [http://www.grails.org Grails] and the [http://jcp.org/en/jsr/detail?id=311 JSR 311] (JAX-RS: The Java API for RESTful Web Services). The examples in the following chapters have been tested with Grails 1.1.1. For instructions how to download and install Grails refer to the [http://grails.org/doc/1.1.1/guide/2.%20Getting%20Started.html#2.1%20Downloading%20and%20Installing Grails reference documentation section 2.1]. 

=Hello world=

==Create a project==

To use the plugin we create a new Grails project. Change the working directory to a location where you want to create a new Grails project and enter 

{{{
grails create-app hello
}}} 

on the command line. This creates a new directory {{{hello}}}. 

==Install the plugin==

To install the plugin from the [http://www.grails.org/plugin/home Grails Plugin Repository], go to the created {{{hello}}} directory and enter 

{{{
grails install-plugin jaxrs
}}} 

This will download the latest released version of the plugin from the [http://www.grails.org/plugin/home Grails Plugin Repository]. For further installation options refer to the [InstallationInstructions installation instructions].

==Create a resource==

To create a JAX-RS resource named {{{test}}} enter

{{{
grails create-resource test
}}}

This will create a {{{TestResource.groovy}}} file under {{{grails-app/resources}}} and a {{{TestResourceTests.groovy}}} file under {{{test/unit}}}. The {{{TestResourceTests.groovy}}} file is a unit test template. The {{{TestResource.groovy}}} file is the generated JAX-RS resource. 

{{{
import javax.ws.rs.GET
import javax.ws.rs.Path
import javax.ws.rs.Produces


@Path('/test')
class TestResource {

    @GET
    @Produces('text/plain')
    String getTestRepresentation() {
        'Test'
    }
    
}
}}}

It defines a single method that responds to HTTP GET operations. The response entity is set to the return value of the method, {{{Test}}} in this example. The content type of the response ({{{Content-Type}}} header) is {{{text/plain}}}. The created resource is ready to use as shown in the next section.

Creating resources via the command line is only one option. An alternative is to create resource files by hand. Any {{{*Resource.groovy}}} file created under {{{grails-app/resources}}} is assumed to be a JAX-RS resource and auto-detected by the grails-jaxrs plugin. 

==Run the application==

To start the application enter 

{{{
grails run-app
}}}

on the comamnd line. Then open a browser window and go to {{{http://localhost:8080/hello/test}}}. The browser should now display "{{{Test}}}".

==Change the code==

The grails-jaxrs plugin also support code changes at runtime i.e. without restarting the server. To demonstrate that, open the {{{TestResource.groovy}}} file and change the return value of {{{getTestRepresentation()}}} to e.g. {{{Hello world}}}. Then, refresh the browser window and you should now see {{{Hello world}}}.

==Using Eclipse==

Using the {{{hello}}} project with the grails-jaxrs plugin in Eclipse requires a bit more than [http://grails.org/Eclipse+IDE+Integration just importing] the {{{hello}}} project. After import, the grails-jaxrs classes are not on the classpath of the project, therefore, you'll see compile errors for generated JAX-RS resources. The best way to resolve the compile errors is to import the grails-jaxrs plugin project as a separate project in Eclipse and reference that project from the {{{hello}}} project. 

To checkout a released version of the grails-jaxrs project enter 

{{{
svn export http://grails-jaxrs.googlecode.com/svn/tags/jaxrs-<version> jaxrs
}}}

on the command line where {{{<version>}}} must be replaced by the version of the plugin you're using. This will create a local directory {{{jaxrs}}}, the root directory of the project. If you use a development snapshot checkout the sources from {{{http://grails-jaxrs.googlecode.com/svn/trunk/jaxrs}}}. 

To import the project into Eclipse go to {{{File -> Import... -> General -> Existing Projects Into Workspace}}} and press {{{Next}}}. Then select the project's root directory and click {{{Finish}}}. You should now see a {{{jaxrs}}} project in the package explorer.

To add this new project as dependency to the {{{hello}}} project, right-click on the {{{hello}}} project and go to {{{Properties -> Java Build Path -> Projects -> Add...}}}. Select the {{{jaxrs}}} project from the list of projects in the workspace and press {{{OK}}}. The compile erros should now disappear.

=Scaffolding=

The grails-jaxrs plugin also supports scaffolding. It allows you to create a RESTful service interface for one or more domain classes based on JAX-RS resource classes. The following sections walk through a very simple example. Please note that the scaffolding feature of the plugin is still *early-access*.

==Create a domain class==

To create a {{{Person}}} domain class go to the project's root directory and enter

{{{
grails create-domain-class person
}}}

Open the generated {{{Person.groovy}}} file (under {{{grails-app/domain}}}) and add two properties, {{{firstName}}} and {{{lastName}}}.

{{{
class Person {

    static constraints = {
    }
    
    String firstName
    
    String lastName
    
}
}}}

==Generate the REST API==

To generate JAX-RS resources that implement the RESTful service interface for that domain class enter

{{{
grails generate-resources person
}}}

This will generate two resource classes, {{{PersonCollectionResource.groovy}}} and {{{PersonResource.groovy}}} that support HTTP POST, GET, PUT and DELETE operations for creating, reading, updating and deleting {{{Person}}} objects, respectively. {{{PersonCollectionResource.groovy}}} is related {{{Person}}} lists, {{{PersonResource.groovy}}} is related to individual {{{Person}}} instances. Let's take a look at how to use the generated RESTful {{{Person}}} interface.

==Use the REST API==

Start the {{{hello}}} application with

{{{
grails run-app
}}}

The following examples use the [http://www.ywebb.com/eclipse-restful-http-client-plugin-http4e/ Eclipse HTTP Client] and a web browser for interacting with the RESTful {{{Person}}} service. 

New person objects can be created by POSTing to {{{http://localhost:8080/hello/person}}}. The {{{Content-Type}}} header must be set to {{{text/xml}}}. The request entity contains a person XML representation.

http://grails-jaxrs.googlecode.com/svn/wiki/images/scaffolding-01.png

After sending the request, the server creates a new person object in the database and returns a representation of it. Note that the returned representation differs from the submitted representation by an {{{id}}} attribute in the {{{<person>}}} element. This id is also contained in the {{{Location}}} response header, the URL of the created resource. The response code is {{{201}}} ({{{CREATED}}}). We create a another person for which the server creates the id 2.

http://grails-jaxrs.googlecode.com/svn/wiki/images/scaffolding-02.png

To GET the list of created persons, open a browser and enter the URL {{{http://localhost:8080/hello/person}}}. This returns an XML representation of the list of persons stored in the database.

http://grails-jaxrs.googlecode.com/svn/wiki/images/scaffolding-03.png

To get the representation of a single person, specify the id in the URL. For example, to get the person with id 1 use {{{http://localhost:8080/hello/person/1}}}

http://grails-jaxrs.googlecode.com/svn/wiki/images/scaffolding-04.png

If you try to get a person that doesn't exist, an error message (with a status code {{{404}}}) is returned.

http://grails-jaxrs.googlecode.com/svn/wiki/images/scaffolding-05.png

In the next step we update the first name of person 1 by PUTting a new representation to {{{http://localhost:8080/hello/person/1}}}. The response is a new representation of the updated person.

http://grails-jaxrs.googlecode.com/svn/wiki/images/scaffolding-06.png

GETting the person list again shows the update of person 1.

http://grails-jaxrs.googlecode.com/svn/wiki/images/scaffolding-07.png

Finally, we delete person 1 by sending a DELETE request to {{{http://localhost:8080/hello/person/1}}}.

http://grails-jaxrs.googlecode.com/svn/wiki/images/scaffolding-08.png

GETting the person lists again shows that person 1 has actually been removed.

http://grails-jaxrs.googlecode.com/svn/wiki/images/scaffolding-09.png

==Source code==

==={{{PersonCollectionResource.groovy}}}===

Let's take a look at the source code of the generated JAX-RS resource classes. Here's the source code for {{{PersonCollectionResource.groovy}}}.

{{{
import static org.grails.jaxrs.response.Responses.*

import javax.ws.rs.GET
import javax.ws.rs.Produces
import javax.ws.rs.Path
import javax.ws.rs.PathParam
import javax.ws.rs.POST
import javax.ws.rs.core.Response

@Path('/person')
@Produces('text/xml')
class PersonCollectionResource {

    @POST
    Response create(Map properties) {
        created new Person(properties).save()
    }

    @GET
    Response readAll() {
        ok Person.findAll()
    }
    
    @Path('/{id}')
    PersonResource getResource(@PathParam('id') String id) {
        new PersonResource(id:id)
    }
        
}
}}}

It is based based on JSR 311 classes and annotations and uses static methods from {{{org.grails.jaxrs.response.Responses}}}. This is a helper class provided by the plugin that implements a very simple DSL consisting of elements {{{created}}}, {{{ok}}} and {{{notFound}}}. 

The {{{PersonCollectionResource}}} class responds to HTTP operations that are releated to person lists. The URL of the person list is {{{http://localhost:8080/hello/person}}} where the {{{/person}}} path is defined by the class-level {{{@Path('/person')}}} annotation.

  * The {{{create}}} method responds to POST requests by storing a new {{{Person}}} object in the database using [http://grails.org/doc/1.1.1/guide/5.%20Object%20Relational%20Mapping%20(GORM).html GORM]. The XML request entity is converted by the plugin into a map that can be used for the construction of a {{{Person}}} domain object. The conversion is done by the {{{org.grails.jaxrs.provider.XMLReader}}}, a JAX-RS provider implemented by the plugin. The persisted domain object is passed as argument to the {{{created}}} method which creates a response from the domain object using the JAX-RS API. Here's a [http://grails-jaxrs.googlecode.com/svn/trunk/jaxrs/src/groovy/org/grails/jaxrs/response/Responses.groovy link to the source code]. The method constructs a {{{URI}}} for the {{{Location}}} response header from the domain object id and uses Grail's XML marshaling for rendering the response entity.
  * The {{{readAll}}} method responds to GET requests and returns an XML representation of a person list. Again we use GORM to get all person object from the database and pass that list as argument to the {{{ok}}} method. This method again uses the JAX-RS API to create the response. Here's a [http://grails-jaxrs.googlecode.com/svn/trunk/jaxrs/src/groovy/org/grails/jaxrs/response/Responses.groovy link to the source code].
  * The {{{getResource}}} method creates another JAX-RS resource whenever a request to the URI template {{{http://localhost:8080/hello/person/{id} }}} is made. The {{{id}}} path parameter in the template is bound to the {{{id}}} parameter of the {{{getResource}}} method. The created JAX-RS {{{PersonResource}}} is then used by the JAX-RS runtime to handle the request to the person with the given id. 

==={{{PersonResource.groovy}}}===

Here's the source code for {{{PersonResource.groovy}}}

{{{
import static org.grails.jaxrs.response.Responses.*

import javax.ws.rs.DELETE
import javax.ws.rs.GET
import javax.ws.rs.Produces
import javax.ws.rs.PUT
import javax.ws.rs.core.Response

@Produces('text/xml')
class PersonResource {
    
    def id
    
    @GET
    Response read() {
        def obj = Person.get(id)
        if (obj) {
            ok obj
        } else {
            notFound Person.class, id
        }
    }
    
    @PUT
    Response update(Map properties) {
        def obj = Person.get(id)
        if (obj) {
            obj.properties = properties 
            ok obj
        } else {
            notFound Person.class, id
        }
    }
    
    @DELETE
    void delete() {
        def obj = Person.get(id)
        if (obj) { 
            obj.delete()
        }
    }
    
}
}}}