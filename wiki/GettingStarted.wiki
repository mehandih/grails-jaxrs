#summary A quick guide to getting started with the JSR 311 plugin for Grails.
#labels Featured

=Overview=

*Please note that this page is currently work in progress!* See also section [#Next_steps next steps].

This page helps you getting started with the JSR 311 plugin for Grails. It is assumed that you have a basic understanding of [http://www.grails.org Grails] and the [http://jcp.org/en/jsr/detail?id=311 JSR 311] (JAX-RS: The Java API for RESTful Web Services).

=Prerequisites=

  * A Grails 1.1.1 (or higher) installation. For instructions how to download and install Grails refer to the [http://grails.org/doc/1.1.1/guide/2.%20Getting%20Started.html#2.1%20Downloading%20and%20Installing Grails reference documentation section 2.1]. 

=Obtain the plugin=

Either download the latest plugin binary directly from [http://code.google.com/p/grails-jaxrs/downloads/list directly from here] or build it from its sources:

  * Checkout the code from Subversion via {{{svn checkout http://grails-jaxrs.googlecode.com/svn/trunk/jaxrs jaxrs}}}
  * Go to the created {{{jaxrs}}} directory.
  * Enter {{{grails test-app}}} on the command line to run the unit and integration tests (optional)
  * Enter {{{grails package-plugin}}} on the command line to create the plugin binary

The filename of the created plugin is {{{grails-jaxrs-<version>.zip}}} where {{{<version>}}} is the current development version. Alternatively, you may want to build the plugin from one of the [http://grails-jaxrs.googlecode.com/svn/tags tagged versions].

=Create a project=

To use the plugin we create a new Grails project. Change the working directory to a location where yuo want to create a new Grails project and enter 

{{{grails create-app hello}}} 

on the command line. This creates a new directory {{{hello}}}. Go to this directory and type 

{{{grails install-plugin /path/to/grails-jaxrs-<version>.zip}}} 

where {{{/path/to}}} needs to be replaced by the absolute or relative path to the {{{grails-jaxrs}}} plugin obtained previously.

In order work with JSR 311 annotations and classes you need to add the [http://download.java.net/maven/2/javax/ws/rs/jsr311-api/1.1/jsr311-api-1.1.jar JSR 311 jar file] (version 1.1) to the {{{lib}}} folder of your project.

=Create a resource=

In the {{{hello}}} project under {{{src/groovy}}} create a new Groovy class {{{HelloResource.groovy}}}:

{{{
import javax.ws.rs.GET
import javax.ws.rs.Path
import javax.ws.rs.Produces

import org.springframework.stereotype.Component

@Component
@Path('/test')
class HelloResource {

    @GET
    @Produces('text/plain')
    String greet() {
        'Hello grails-jaxrs'
    }
    
}
}}}

This implements a resource that responds to {{{HTTP GET}}} and  produces representations of content type {{{text/plain}}}. The path of the resource URL is {{{/test}}}.

=Setup the application context=

Before the application can be started we need to add the resource to the Spring application context. We do this with a [http://static.springsource.org/spring/docs/2.5.x/reference/xsd-config.html#xsd-config-body-schemas-context-component-scan component scan]. A component scan looks in the classpath for beans annotated with {{{@Component}}} and adds them to the application context. Here's the application context XML file ({{{resources.xml}}}) that needs to be added to the {{{grails-app/conf/spring}}} directory of the {{{hello}}} project.

{{{
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context-2.5.xsd">

    <context:annotation-config/>
    <context:component-scan base-package="**"/>

</beans>
}}}

This scans components from all packages including the default package. If you don't want to use {{{context:component-scan}}} add the bean {{{<bean class="HelloResource" />}}} directly to the application context.

=Run the application=

To start the application type 

{{{grails run-app}}}

on the comamnd line. Then open a browser window and go to {{{http://localhost:8080/hello/test}}}. You should now see a "Hello grails-jaxrs" in the browser.

=Next steps=

This documentation will soon be extended to show you how to

  * [#Configuration use Grails controllers besides JAX-RS resources]
  * [#Applying_filters apply Grails filters to JAX-RS resources]
  * [#Using_GORM use Grails object relational mapping (GORM)]
  * [#Using_GORM use XML marshaling in resource and provider classes]
  * write your own provider (reader/writer) classes
  * auto-inject Grails services into resource classes
  * generate resource classes for domain classes
  * deploy your application to Google App Engine
  * ...

=Advanced topics=

==Configuration==

By default all requests are forwarded to the {{{JaxrsController}}} which is contained in the {{{grails-jaxrs}}} plugin. In order to use "regular" Grails controllers besides the {{{JaxrsController}}} we need to extend the URL mappings. 

Instead of extending the {{{grails-app/conf/UrlMappings.groovy}}} file directly the URL mappings for the {{{JaxrsController}}} are set via the {{{org.grails.jaxrs.url.mappings}}} configuration property. The property value is a list of URL patterns. For example, assuming that a Grails application is accessible under http://localhost:8080/hello where {{{/hello}}} is the context path and all JAX-RS resources are accessible via

  * http://localhost:8080/hello/test/... and
  * http://localhost:8080/hello/notes/...

we need to add the following entry to {{{grails-app/conf/Config.groovy}}}:

  * {{{org.grails.jaxrs.url.mappings=['/test', '/notes']}}}

This ensures that only requests with a URL path matching {{{/test/...}}} and {{{/notes/...}}} are forwarded to the {{{JaxrsController}}}, all other requests may go to other Grails controllers. More detailed, the {{{grails-jaxrs}}} plugin creates the following URL mappings when it is loaded:

  * {{{"/test"(controller:"jaxrs")}}}
  * {{{"/test/**"(controller:"jaxrs")}}}
  * {{{"/notes"(controller:"jaxrs")}}}
  * {{{"/notes/**"(controller:"jaxrs")}}}

==Applying filters==

[http://grails.org/doc/1.1.1/guide/6.%20The%20Web%20Layer.html#6.6%20Filters Grails filters] can be applied to JAX-RS resources as well. For example, to add a filter for the {{{/test/**}}} URL pattern, create a file {{{TestFilters.groovy}}} under {{{grails-app/conf}}} with a content like

{{{
class TestFilters {

    def filters = {
            
        testUris(uri:'/test/**') {
            before = {
                // do some preprocessing
            }
            after = {
                // do some postprocessing
            }
            
        }   
    }
}
}}}

==Using GORM==

Usage of [http://grails.org/doc/1.1.1/guide/5.%20Object%20Relational%20Mapping%20(GORM).html GORM] is demonstrated on a (over-simplified) web application that keeps track of notes that have been POSTed via HTTP.

  * POSTing to {{{http://localhost:8080/hello/notes}}} creates a new {{{Note}}} domain object in the database containing the actual note from the request body. The request content type is {{{text/plain}}}. The response content type is {{{text/xml}}} representing the created domain object including its identifier. The response {{{Location}}} header contains the URL of the created note resource.

  * GETing from {{{http://localhost:8080/hello/notes}}} obtains a list of all created notes so far or an empty list. The response content type is {{{text/xml}}}.

  * GETing from {{{http://localhost:8080/hello/notes/{id}}}} obtains a note with a certain {{{id}}} or an error message (along with status code 404) if a note with the given {{{id}}} doesn't exist.

The first step is to create the {{{Note}}} domain object. You can either do this via {{{grails create-domain-class note}}} from the command line or directly add a {{{Note.groovy}}} file with the following content to the {{{grails-app/domain}}} directory.

{{{
class Note {

    static constraints = {
    }
    
    String text
    
}
}}}

The only thing a note object stores is the note {{{text}}} (and an {{{id}}} property that is available on every Grails domain object).

For creating new {{{Note}}} instances i.e. note resources we POST the notes text to {{{http://localhost:8080/hello/notes}}}. This resource is implemented with a {{{NotesResource}}} class

{{{
import grails.converters.*
 
import javax.ws.rs.Consumes
import javax.ws.rs.GET
import javax.ws.rs.Produces
import javax.ws.rs.Path
import javax.ws.rs.PathParam
import javax.ws.rs.POST
import javax.ws.rs.core.Response
import javax.ws.rs.core.UriBuilder

import org.springframework.stereotype.Component

@Component
@Path('/notes')
class NotesResource {

     @POST
     @Consumes('text/plain')
     @Produces('text/xml')
     Response addNote(String text) {
         def note = new Note(text:text).save()
         URI uri = UriBuilder.fromPath(note.id as String).build()
         Response.created(uri).entity(note as XML).build()
     }

     @GET
     @Produces('text/xml')
     Response getNotes() {
         Response.ok(Note.findAll() as XML).build()
     }
     
     @Path('/{id}')
     NoteResource getNote(@PathParam('id') String id) {
         new NoteResource(note:Note.get(id))
     }
}
}}}

Save this class as {{{NotesResource.groovy}}} in the {{{src/groovy}}} directory. Let's take a closer look. The class-level {{{@Path}}} annotation makes this resource accessible under the {{{/notes}}} path i.e. the full URL is {{{http://localhost:8080/hello/notes}}}. POSTing to this URL will call the {{{addNote(String)}}} method passing the request body via the {{{text}}} parameter. The text parameter is used to construct a {{{Note}}} object which is then stored in the database. The URL for the newly created note is generated in the second line. We use this URL to set the {{{Location}}} response header with {{{Response.created(uri)}}}. The response body contains the XML representation of the note object. To create the XML representation the XML converter of Grails is used.



...