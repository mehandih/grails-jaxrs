#summary Advanced features of the JSR 311 plugin for Grails.
#labels Featured

<wiki:toc/>

=Configuration=

==URL mappings==

When the grails-jaxrs plugin is installed, requests paths matching {{{/api/**}}} are forwarded to a {{{JaxrsController}}} which is part of the plugin. This default URL mapping can be changed via the {{{org.grails.jaxrs.url.mappings}}} configuration property in {{{grails-app/conf/Config.groovy}}}. For example, setting this property to 

  * {{{org.grails.jaxrs.url.mappings=['/abc', '/xyz']}}}

will create the following URL mappings for the {{{JaxrsController}}}:

  * {{{"/abc"(controller:"jaxrs")}}}
  * {{{"/abc/**"(controller:"jaxrs")}}}
  * {{{"/xyz"(controller:"jaxrs")}}}
  * {{{"/xyz/**"(controller:"jaxrs")}}}

{{{@Path}}} annotation values in JAX-RS resource classes must be set accordingly e.g. 

{{{
@Path('/abc/test1')
class TestResource1 {
  ...    
}
}}}

or 

{{{
@Path('/xyz/test2')
class TestResource2 {
  ...    
}
}}}

Custom mappings replace the default {{{/api/**}}} mapping. If the default mapping should apply in addition to custom mappings it must be added to the {{{org.grails.jaxrs.url.mappings}}} list.

  * {{{org.grails.jaxrs.url.mappings=['/abc', '/xyz', '/api']}}}

==JAX-RS implementation==

The grails-jaxrs plugin allows to choose between [https://jersey.dev.java.net/ Jersey] (version 1.1.4.1) and [http://www.restlet.org/ Restlet] (version 2.0-M6) as JAX-RS implementations. By default, Jersey is used. If you want to use Restlet instead, add the following line to {{{grails-app/conf/Config.groovy}}}.

{{{
org.grails.jaxrs.provider.name='restlet'
}}}

Restlet was added because it supports deployments to [http://code.google.com/appengine/ Google App Engine] (GAE). For instructions how to deploy a grails-jaxrs application to Google App Engine refer to the [#Google_App_Engine Google App Engine] section. 

The main obstacle for deploying Jersey to Google App Engine was missing support for JAXB in the past. This has been resolved with the App Engine SDK 1.2.8. However, attempts to deploy Jersey to Google App Engine revealed other issues. We plan to resolve these issues in upcoming versions of this plugin.

==JAX-RS resource scope==

By default, JAX-RS resource classes are instantiated with every request which corresponds to the following entry in {{{grails-app/conf/Config.groovy}}}.

{{{
org.grails.jaxrs.resource.scope='prototype'
}}}

Since this is the default you can omit this entry as well. On the other hand, if you want that your JAX-RS resources are singletons, add the following configuration entry.

{{{
org.grails.jaxrs.resource.scope='singleton'
}}}

==Domain object providers==

From version 0.3 onwards the grails-jaxrs plugin comes with JAX-RS providers for converting between Grails domain objects and XML/JSON representations. Domain object providers are explained in detail in the [#Entity_providers entity providers] section. Here, only the configuration options are summarized. The grails-jaxrs plugin comes with two domain object providers:

  * {{{org.grails.jaxrs.provider.DomainObjectReader}}}
  * {{{org.grails.jaxrs.provider.DomainObjectWriter}}}

These can selectively be disabled by using the following configuration properties in {{{grails-app/conf/Config.groovy}}}.

  * {{{org.grails.jaxrs.doreader.disable}}}
  * {{{org.grails.jaxrs.dowriter.disable}}}

Setting these properties to {{{true}}} will disable the default domain object providers. Another {{{DomainObjectWriter}}} configuration option, {{{org.grails.jaxrs.dowriter.require.generic.collections}}} is explained in the [#Entity_providers entity providers] section.

=Applying filters=

[http://grails.org/doc/1.1.2/guide/6.%20The%20Web%20Layer.html#6.6%20Filters Grails filters] can be applied to JAX-RS resources as well. For example, to add a filter for the {{{/api/test/**}}} URL pattern, create a file {{{TestFilters.groovy}}} under {{{grails-app/conf}}} with a content like

{{{
class TestFilters {

    def filters = {
            
        testUris(uri:'/api/test/**') {
            before = {
                // do some preprocessing
            }
            after = {
                // do some postprocessing
            }
            
        }   
    }
}
}}}

=Service injection=

Services can be auto-injected into resource and [#Entity_providers provider] objects by name. Assuming we have a service class named {{{TestService.groovy}}} in {{{grails-app/services}}}

{{{
class TestService {

     String greet(String name) {
         'Hello ' + (name ? name : 'unknown')
     }
    
}
}}}

then we can auto-inject it by defining a {{{testService}}} property like in the following resource class.

{{{
// imports omitted ...

@Path('/test')
class TestResource {

    def testService // injected
    
    @GET
    @Produces('text/plain')
    String getTestRepresentation(@QueryParam('name') String name) {
        testService.greet(name)
    }
    
}
}}}

=Scaffolding=

The grails-jaxrs plugin supports scaffolding. Please note that the scaffolding feature in version 0.2 is still *early access*. For an introductory scaffolding example refer to the [GettingStarted#Scaffolding scaffolding section of the getting started guide]. The following subsections walk through the generated example code. 

=={{{PersonCollectionResource.groovy}}}==

Here's the source code for {{{PersonCollectionResource.groovy}}}.

{{{
import static org.grails.jaxrs.response.Responses.*

import javax.ws.rs.GET
import javax.ws.rs.Produces
import javax.ws.rs.Path
import javax.ws.rs.PathParam
import javax.ws.rs.POST
import javax.ws.rs.core.Response

@Path('/person')
@Produces('text/xml')
class PersonCollectionResource {

    @POST
    Response create(Map properties) {
        created new Person(properties).save()
    }

    @GET
    Response readAll() {
        ok Person.findAll()
    }
    
    @Path('/{id}')
    PersonResource getResource(@PathParam('id') String id) {
        new PersonResource(id:id)
    }
        
}
}}}

It is based based on JSR 311 classes and annotations and uses static methods from {{{org.grails.jaxrs.response.Responses}}}. This is a helper class provided by the plugin that implements a very simple DSL consisting of elements {{{created}}}, {{{ok}}} and {{{notFound}}}. 

The {{{PersonCollectionResource}}} class responds to HTTP operations that are releated to person lists. The URL of the person list is {{{http://localhost:8080/hello/person}}} where the {{{/person}}} path is defined by the class-level {{{@Path('/person')}}} annotation.

  * The {{{create}}} method responds to POST requests by storing a new {{{Person}}} object in the database using [http://grails.org/doc/1.1.1/guide/5.%20Object%20Relational%20Mapping%20(GORM).html GORM]. The XML request entity is converted by the plugin into a map that can be used for the construction of a {{{Person}}} domain object. The conversion is done by the {{{org.grails.jaxrs.provider.XMLReader}}}, a JAX-RS provider implemented by the plugin. The persisted domain object is passed as argument to the {{{created}}} method which creates a response from the domain object using the JAX-RS API. Here's a [http://grails-jaxrs.googlecode.com/svn/trunk/jaxrs/src/groovy/org/grails/jaxrs/response/Responses.groovy link to the source code]. The method constructs a {{{URI}}} for the {{{Location}}} response header from the domain object id and uses Grail's XML marshaling for rendering the response entity.
  * The {{{readAll}}} method responds to GET requests and returns an XML representation of a person list. Again we use GORM to get all person object from the database and pass that list as argument to the {{{ok}}} method. This method again uses the JAX-RS API to create the response. Here's a [http://grails-jaxrs.googlecode.com/svn/trunk/jaxrs/src/groovy/org/grails/jaxrs/response/Responses.groovy link to the source code].
  * The {{{getResource}}} method creates another JAX-RS resource whenever a request to the URI template {{{http://localhost:8080/hello/person/{id} }}} is made. The {{{id}}} path parameter in the template is bound to the {{{id}}} parameter of the {{{getResource}}} method. The created JAX-RS {{{PersonResource}}} is then used by the JAX-RS runtime to handle the request to the person with the given id. 

=={{{PersonResource.groovy}}}==

Here's the source code for {{{PersonResource.groovy}}}.

{{{
import static org.grails.jaxrs.response.Responses.*

import javax.ws.rs.DELETE
import javax.ws.rs.GET
import javax.ws.rs.Produces
import javax.ws.rs.PUT
import javax.ws.rs.core.Response

@Produces('text/xml')
class PersonResource {
    
    def id
    
    @GET
    Response read() {
        def obj = Person.get(id)
        if (obj) {
            ok obj
        } else {
            notFound Person.class, id
        }
    }
    
    @PUT
    Response update(Map properties) {
        def obj = Person.get(id)
        if (obj) {
            obj.properties = properties 
            ok obj
        } else {
            notFound Person.class, id
        }
    }
    
    @DELETE
    void delete() {
        def obj = Person.get(id)
        if (obj) { 
            obj.delete()
        }
    }
    
}
}}}

The {{{id}}} property is set during construction of the resource and is used for database operation. This class implements the methods {{{read}}}, {{{update}}} and {{{delete}}} to handle GET, PUT and DELETE requests, respectivly. It also uses GORM for database operations and relies on helper methods of {{{org.grails.jaxrs.response.Responses}}} to create repsonses via the JAX-RS API.

=Using GORM=

*Hint*: the example described in this section can be implemented much easier using [#Scaffolding Scaffolding]. Most of the code presented here can be generated since version 0.2 of grails-jaxrs. The following example nevertheless provides useful information how to implement simple RESTful service interfaces by hand (i.e. without code generation).

Usage of [http://grails.org/doc/1.1.1/guide/5.%20Object%20Relational%20Mapping%20(GORM).html GORM] is demonstrated on a (over-simplified) web application that keeps track of notes that have been POSTed via HTTP.

  * POSTing to {{{http://localhost:8080/hello/notes}}} creates a new {{{Note}}} domain object in the database containing the actual note from the request body. The request content type is {{{text/plain}}}. The response content type is {{{text/xml}}} representing the created domain object including its identifier. The response {{{Location}}} header contains the URL of the created note resource.

  * GETing from {{{http://localhost:8080/hello/notes}}} obtains a list of all created notes so far or an empty list. The response content type is {{{text/xml}}}.

  * GETing from {{{http://localhost:8080/hello/notes/{id} }}} obtains a note with a certain {{{id}}} or an error message (along with status code 404) if a note with the given {{{id}}} doesn't exist.

The first step is to create the {{{Note}}} domain object. This can be either done via {{{grails create-domain-class note}}} from the command line or manually by adding a {{{Note.groovy}}} file with the following content to the {{{grails-app/domain}}} directory.

{{{
class Note {

    static constraints = {
    }
    
    String text
    
}
}}}

The only thing a note object stores is the note {{{text}}} (and an {{{id}}} property that is available on every Grails domain object).

For creating new {{{Note}}} instances i.e. note resources we POST the notes text to {{{http://localhost:8080/hello/notes}}}. This resource is implemented with a {{{NotesResource}}} class

{{{
import grails.converters.*
 
import javax.ws.rs.Consumes
import javax.ws.rs.GET
import javax.ws.rs.Produces
import javax.ws.rs.Path
import javax.ws.rs.PathParam
import javax.ws.rs.POST
import javax.ws.rs.core.Response
import javax.ws.rs.core.UriBuilder

@Path('/notes')
class NotesResource {

     @POST
     @Consumes('text/plain')
     @Produces('text/xml')
     Response addNote(String text) {
         def note = new Note(text:text).save()
         URI uri = UriBuilder.fromPath(note.id as String).build()
         Response.created(uri).entity(note as XML).build()
     }

     @GET
     @Produces('text/xml')
     Response getNotes() {
         Response.ok(Note.findAll() as XML).build()
     }
     
}
}}}

Save this class as {{{NotesResource.groovy}}} in the {{{grails-app/resources}}} directory. Let's take a closer look at it. The class-level {{{@Path}}} annotation makes this resource accessible under the {{{/notes}}} path i.e. the full URL is {{{http://localhost:8080/hello/notes}}}. POSTing to this URL will call the {{{addNote(String)}}} method passing the request body via the {{{text}}} parameter. The text parameter is used to construct a {{{Note}}} object which is then stored in the database. The URL for the newly created note is constructed in the second line. We use this URL to set the {{{Location}}} response header with {{{Response.created(uri)}}}. The response body contains the XML representation of the note object. To create the XML representation the XML converter of Grails is used. Here's a sample HTTP request:

{{{
POST /hello/notes/ HTTP/1.1
Content-Type: text/plain
Host: localhost:8080
Content-Length: 27

Don't forget to learn Scala
}}}

Here's a sample HTTP response:

{{{
HTTP/1.1 201 Created
Content-Type: text/xml
Location: http://localhost:8080/hello/notes/1

<?xml version="1.0" encoding="UTF-8"?>
<note id="1">
  <text>Don't forget to learn Scala</text>
</note>
}}}

To obtain a list of all notes send a GET request to {{{http://localhost:8080/hello/notes}}} which will call the {{{getNotes()}}} method. This method again uses the Grails XML converter to create an XML representation of the notes collection, such as 

{{{
HTTP/1.1 200 OK
Content-Type: text/xml

<?xml version="1.0" encoding="UTF-8"?>
<list>
  <note id="1">
    <text>Don't forget to learn Scala</text>
  </note>
  <note id="2">
    <text>Another important note</text>
  </note>
</list>
}}}

Finally we want to obtain individual notes via {{{http://localhost:8080/hello/notes/{id} }}} where {{{id}}} is in range 1..n. This can be achieved by adding a {{{getNote(String}}} method to the {{{NotesResource}}} class:

{{{
@Component
@Path('/notes')
class NotesResource {

     // ... other methods omitted

     @Path('/{id}')
     NoteResource getNote(@PathParam('id') String id) {
         new NoteResource(note:Note.get(id))
     }
     
}
}}}

Instead of using a fixed path we use a _path template_ where the last path segment is the variable part of the path. It is bound to the {{{id}}} parameter of the {{{getNote(String)}}} method using a {{{@PathParam}}} annotation. Instead of rendering the response directly in the {{{NotesResource}}} class it is delegated to the {{{NoteResource}}} class after we've loaded the note object from the database:

{{{
import static javax.ws.rs.core.Response.Status.NOT_FOUND
 
import grails.converters.* 
 
import javax.ws.rs.GET
import javax.ws.rs.Produces
import javax.ws.rs.core.Response

class NoteResource {

    Note note

    @GET
    @Produces('text/xml')
    Response getNote() {
        if (note) {
            Response.ok(note as XML).build()
        } else {
            Response.status(NOT_FOUND).entity('<error>not found</error>').build()
        } 
    }
    
}
}}}

If a note object with the requested id exists an XML representation is returned, otherwise, an error message is created along with a status code 404 (NOT FOUND). For example, GETing the note {{{http://localhost:8080/hello/notes/1}}} returns

{{{
HTTP/1.1 200 OK
Content-Type: text/xml

<?xml version="1.0" encoding="UTF-8"?>
<note id="1">
  <text>Don't forget to learn Scala</text>
</note>
}}}

=Entity providers=

Entity providers supply mapping services between representations and their associated Java types. They are used to factor out parsing and rendering code from resource classes. The {{{grails-jaxrs}}} plugin provides abstract base classes for entity providers. 

  * {{{org.grails.jaxrs.support.MessageBodyReaderSupport<T>}}}
  * {{{org.grails.jaxrs.support.MessageBodyWriterSupport<T>}}}

These can be used for simple use cases. For example, if you want to use Groovy's markup builder for creating custom XML responses from {{{Note}}} objects (see [#Using_GORM previous] section) implement a {{{NoteWriter}}} provider class like following:

{{{
import groovy.xml.MarkupBuilder

import java.io.OutputStreamWriter

import javax.ws.rs.Produces
import javax.ws.rs.core.MultivaluedMap
import javax.ws.rs.ext.Provider

import org.grails.jaxrs.support.MessageBodyWriterSupport

@Provider
@Produces('text/xml')
class NoteWriter extends MessageBodyWriterSupport<Note> {
    
    void writeTo(Note entity, MultivaluedMap httpHeaders, OutputStream entityStream) {
        def builder = new MarkupBuilder(new OutputStreamWriter(entityStream)) 
        builder.note {
            id(entity.id)
            content(entity.text)
        }
        // Alternative (default rendering):
        // entityStream << (entity as XML)
    }
   
}
}}}

When you place that entity provider into the {{{grails-app/providers}}} directory then it is auto-detected by Grails. Having such a provider in place, resource methods can return a {{{Note}}} object directly in the response object:

{{{
...

class NoteResource {

    Note note

    @GET
    @Produces('text/xml')
    Response getNote() {
        if (note) {
            // custom XML rendering done by provider (NoteWriter)
            Response.ok(note).build()
            //Response.ok(note as XML).build()
        } else {
            Response.status(NOT_FOUND).entity('<error>not found</error>').build()
        } 
    }
     
}
}}}

In this case the response looks like:

{{{
HTTP/1.1 200 OK
Content-Type: text/xml

<?xml version="1.0" encoding="UTF-8"?>
<note>
  <id>1</id>
  <content>Don't forget to learn Scala</content>
</note>
}}}

=Google App Engine=

This section describes how to get the [GettingStarted#Hello_world hello world] example running on Google App Engine. 

  * Install the [http://grails.org/plugin/app-engine Grails AppEngine plugin].
  * Create a Grails application and JAX-RS resource as described in the [GettingStarted#Hello_world hello world] example.
  * Add the following entries to {{{grails-app/conf/Config.groovy}}}
{{{
org.grails.jaxrs.url.mappings=['/test']
org.grails.jaxrs.provider.name='restlet'
// replace <application-name> with the 
// actual App Engine application name
google.appengine.application='<application-name>'
}}}
  * Open a shell at the root directory of the hello world application.
  * Set the application version to 1 with 
{{{
grails set-version 1
}}}
  * Run the application locally with {{{grails app-engine run}}}.
  * Enter the URL {{{http://localhost:8080/test?name=Tester}}} into your browser and the browser window should display {{{Hello Tester}}}.
  * Package the plugin with {{{grails app-engine package}}}.
  * Deploy the application with the {{{appcfg}}} command-line tool from your [http://code.google.com/appengine/downloads.html App Engine SDK]. 
    * On Linux, enter 
{{{
$APPENGINE_HOME/bin/appcfg.sh update ./target/war
}}}
    * On Windows, enter 
{{{
%APPENGINE_HOME%\bin\appcfg.cmd update .\target\war
}}}
  * When prompted enter email and password to authenticate at Google App Engine.
  * Once deployment is done go enter the URL {{{http://<application-name>.appspot.com/test?name=Tester}}} into your browser and the browser window should display {{{Hello Tester}}}. It may take 10-20 seconds for Google App Engine to initialize the Grails application the first time. Subsequent requests are served much faster.

Deployments of applications that use GORM have not been tested yet but should be possible with the Grails {{{gorm-jpa}}} plugin. In order to use the plugin make sure to choose JPA for persistence when installing the Grails {{{app-engine}}} plugin. Initial tests on Windows resulted in classpath issues after installation of the {{{gorm-jpa}}} plugin. I'll post a message to the [http://groups.google.com/group/grails-jaxrs grails-jaxrs] group as soon as there are updates.